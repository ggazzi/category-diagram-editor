module GraphView
    exposing
        ( Node
        , NodeId
        , Edge
        , Endpoint
        , Shape(..)
        , State
        , init
        , Config
        , Event
        , Target(..)
        , basicConfig
        , customConfig
        , onClick
        , onDragStart
        , onDragEnd
        , onDragBy
        , onMouseUp
        , InternalMsg
        , update
        , subscriptions
        , view
        )

import Draggable.CustomInfo as Draggable exposing (Delta)
import Draggable.CustomInfo.Events as Draggable
import Html exposing (Html)
import Html.Attributes exposing (style)
import Json.Decode as Json
import Mouse.State as Mouse
import Position exposing (Position)
import Svg exposing (Svg)
import Svg.Attributes as Attr
import Svg.Events as Svg
import Svg.Keyed


-- MODEL


{-| Type containing graphical information about a node.
-}
type alias Node =
    { id : NodeId
    , name : String
    , x : Float
    , y : Float
    , shape : Shape
    }


{-| Type used to identify nodes.
-}
type alias NodeId =
    Int


{-| Type containing graphical information about an edge.
-}
type alias Edge =
    { source : Endpoint
    , target : Endpoint
    }


{-| Type containing graphical information about an edge's endpoint, which may not be an actual node.
-}
type alias Endpoint =
    { key : Maybe Int
    , x : Float
    , y : Float
    , shape : Shape
    }


type Shape
    = None
    | Circle Float


{-| Type representing possible targets of interaction.
-}
type Target
    = OnBackground
    | OnNode NodeId


{-| Internal state of the graph view.
-}
type alias State =
    { drag : Draggable.State (Mouse.State Target) }


{-| Initial state for the graph view.
-}
init : State
init =
    { drag = Draggable.init }



-- CONFIG


{-| Configuration of the graph view, with functions that create messages for particular events of the view.
-}
type Config msg
    = Config
        { dragConfig : Draggable.Config (Mouse.State Target) msg
        , onMouseUp : Target -> Maybe (Json.Decoder msg)
        }


type Event msg
    = FunctionEvent (Config msg -> Config msg)
    | DraggableEvent (Draggable.Event (Mouse.State Target) msg)


defaultConfig : Draggable.Config (Mouse.State Target) msg -> Config msg
defaultConfig dragConfig =
    Config
        { dragConfig = dragConfig
        , onMouseUp = \_ -> Nothing
        }


basicConfig : (Delta -> msg) -> Config msg
basicConfig =
    defaultConfig << Draggable.basicConfig


customConfig : List (Event msg) -> Config msg
customConfig events =
    let
        initialConfig =
            defaultConfig <| Draggable.customConfig <| List.filterMap asDraggableEvent events

        asDraggableEvent event =
            case event of
                FunctionEvent _ ->
                    Nothing

                DraggableEvent ev ->
                    Just ev

        asFunction event =
            case event of
                FunctionEvent f ->
                    Just f

                DraggableEvent _ ->
                    Nothing

        applyAllTo initial =
            List.foldl (<|) initial
    in
        events
            |> List.filterMap asFunction
            |> applyAllTo initialConfig


onClick : (Mouse.State Target -> msg) -> Event msg
onClick =
    DraggableEvent << Draggable.onClick


onDragStart : (Mouse.State Target -> msg) -> Event msg
onDragStart =
    DraggableEvent << Draggable.onDragStart


onDragBy : (Delta -> msg) -> Event msg
onDragBy =
    DraggableEvent << Draggable.onDragBy


onDragEnd : msg -> Event msg
onDragEnd =
    DraggableEvent << Draggable.onDragEnd


onMouseUp : (Target -> Maybe (Json.Decoder msg)) -> Event msg
onMouseUp decoder =
    FunctionEvent <| \(Config config) -> Config { config | onMouseUp = decoder }



-- UPDATE


{-| Internal messages for dealing with the view logic.
-}
type alias InternalMsg =
    Draggable.Msg (Mouse.State Target)


{-| Handle internal update messages for the view model.
-}
update : Config msg -> InternalMsg -> { model | graphView : State } -> ( { model | graphView : State }, Cmd msg )
update (Config { dragConfig }) msg ({ graphView } as model) =
    let
        ( graphView_, cmd ) =
            Draggable.update dragConfig msg graphView
    in
        ( { model | graphView = graphView_ }, cmd )



-- SUBSCRIPTIONS


{-| Create mouse subscriptions used for dragging.
-}
subscriptions : (InternalMsg -> msg) -> State -> Sub msg
subscriptions envelope { drag } =
    Draggable.subscriptions envelope drag



-- VIEW


{-|
Create a graph view. The first argument wraps internal messagens into an envelope for the outer application. The `Config` argument describes the messages generated by the view events. The `List Node` and `List Edge` arguments provide the graph to be displayed.

  __Note:__ The `List Node` and `List Edge` arguments should be computed with information from the model, but generally not stored in it. The `Config` is view or update code and should generally be kept separate from the model.
-}
view : (InternalMsg -> msg) -> Config msg -> List Node -> List Edge -> Html msg
view envelope config nodes edges =
    Svg.svg
        [ style
            [ ( "margin", "20px" )
            , ( "width", "800px" )
            , ( "height", "600px" )
            ]
        ]
        [ Svg.defs [] [ arrowhead.svg ]
        , background envelope config
        , edges
            |> List.map (\e -> ( toString <| edgeKey e, edgeView e ))
            |> Svg.Keyed.node "g"
                [ Attr.class "edges-view"
                , Attr.stroke "black"
                , Attr.cursor "pointer"
                ]
        , nodes
            |> List.map (\node -> ( toString node.id, nodeView envelope config node ))
            |> Svg.Keyed.node "g" [ Attr.class "nodes-view" ]
        ]


background : (InternalMsg -> msg) -> Config msg -> Svg msg
background envelope config =
    Svg.rect
        ([ Attr.width "100%"
         , Attr.height "100%"
         , Attr.fill "transparent"
         , Attr.stroke "lightgrey"
         , Attr.strokeWidth "2px"
         , Attr.rx "5px"
         , Attr.ry "5px"
         , Attr.cursor "crosshair"
         ]
            ++ handlerAttributes envelope config OnBackground
        )
        []



-- NODES


nodeView : (InternalMsg -> msg) -> Config msg -> Node -> Svg msg
nodeView envelope config { id, name, x, y, shape } =
    let
        nodeWrapper =
            Svg.g
                ([ Attr.class "node"
                 , Attr.transform translate
                 , Attr.cursor "pointer"
                 ]
                    ++ handlerAttributes envelope config (OnNode id)
                )

        translate =
            "translate(" ++ toString x ++ "," ++ toString y ++ ")"
    in
        nodeWrapper <|
            case shape of
                Circle radius ->
                    [ Svg.circle
                        [ Attr.r (toString radius)
                        , Attr.fill "white"
                        , Attr.stroke "lightgrey"
                        , Attr.strokeWidth "1"
                        ]
                        []
                    , Svg.text_
                        [ Attr.textAnchor "middle"
                        , Attr.y "5"
                        ]
                        [ Svg.text name
                        ]
                    ]

                None ->
                    []



-- EDGES


edgeKey : { e | source : { b | key : a }, target : { d | key : c } } -> String
edgeKey { source, target } =
    toString ( source.key, target.key )


edgeView : Edge -> Svg msg
edgeView edge =
    let
        { source, target, length } =
            adjustEndpoints edge
    in
        Svg.path
            [ Attr.class "morphism"
            , Attr.stroke edgeColor
            , Attr.strokeWidth "1.5"
            , Attr.markerEnd ("url(#" ++ arrowhead.id ++ ")")
            , Attr.d <|
                if length == 0 then
                    "M0 0"
                    -- Dummy path, nothing should be shown
                else
                    moveTo source ++ lineTo target
            ]
            []


adjustEndpoints : Edge -> { source : Position, target : Position, length : Float }
adjustEndpoints { source, target } =
    let
        displaceBy amount { x, y } =
            { x = x + amount * dx / length
            , y = y + amount * dy / length
            }

        ( dx, dy ) =
            ( target.x - source.x, target.y - source.y )

        length =
            sqrt (dx * dx + dy * dy)
    in
        { source = source |> displaceBy (sourceDisplacement source)
        , target = target |> displaceBy (targetDisplacement target)
        , length = length
        }


sourceDisplacement : Endpoint -> Float
sourceDisplacement { shape } =
    case shape of
        None ->
            0

        Circle radius ->
            radius


targetDisplacement : Endpoint -> Float
targetDisplacement { shape } =
    case shape of
        None ->
            -arrowhead.length

        Circle radius ->
            -(radius + arrowhead.length)



-- UTILITIES


handlerAttributes : (InternalMsg -> msg) -> Config msg -> Target -> List (Svg.Attribute msg)
handlerAttributes envelope (Config { dragConfig, onMouseUp }) target =
    let
        asHandlerAttribute ( event, handler ) =
            Maybe.map (Svg.on event) handler
    in
        Draggable.mouseTrigger envelope (Mouse.state <| target)
            :: List.filterMap asHandlerAttribute [ ( "mouseup", onMouseUp target ) ]


type alias Marker a =
    { id : String
    , length : Float
    , svg : Svg a
    }


type alias PathFragment =
    String


moveTo : Position -> PathFragment
moveTo { x, y } =
    "M" ++ toString x ++ " " ++ toString y


lineTo : Position -> PathFragment
lineTo { x, y } =
    "L" ++ toString x ++ " " ++ toString y



-- VIEW CONSTANTS


edgeColor : String
edgeColor =
    "black"


arrowhead : Marker a
arrowhead =
    { id = "arrowhead"
    , length = 2
    , svg =
        Svg.marker
            [ Attr.id "arrowhead"
            , Attr.viewBox "0 -5 10 10"
            , Attr.refX "8"
            , Attr.markerWidth "4"
            , Attr.markerHeight "6"
            , Attr.orient "auto"
            ]
            [ Svg.path
                [ Attr.d "M0,-5L10,0L0,5"
                , Attr.fill "transparent"
                , Attr.stroke edgeColor
                , Attr.strokeWidth "2"
                ]
                []
            ]
    }
