module GraphView
    exposing
        ( Node
        , NodeId
        , Edge
        , Endpoint
        , Shape(..)
        , State
        , init
        , Config
        , Event
        , Target(..)
        , basicConfig
        , customConfig
        , onClick
        , onDragStart
        , onDragEnd
        , onDragBy
        , InternalMsg
        , update
        , subscriptions
        , view
        )

import Draggable.CustomInfo as Draggable exposing (Delta)
import Draggable.CustomInfo.Events as Draggable
import Html exposing (Html)
import Html.Attributes exposing (style)
import Mouse.State as Mouse
import Position exposing (Position)
import Svg exposing (Svg)
import Svg.Attributes as Attr
import Svg.Keyed


-- MODEL


{-| Type containing graphical information about a node.
-}
type alias Node =
    { id : NodeId
    , name : String
    , x : Float
    , y : Float
    , shape : Shape
    }


{-| Type used to identify nodes.
-}
type alias NodeId =
    Int


{-| Type containing graphical information about an edge.
-}
type alias Edge =
    { source : Endpoint
    , target : Endpoint
    }


{-| Type containing graphical information about an edge's endpoint, which may not be an actual node.
-}
type alias Endpoint =
    { key : Maybe Int
    , x : Float
    , y : Float
    , shape : Shape
    }


type Shape
    = None
    | Circle Float


{-| Type representing possible targets of interaction.
-}
type Target
    = OnBackground
    | OnNode NodeId


{-| Internal state of the graph view.
-}
type alias State =
    { drag : Draggable.State (Mouse.State Target) }


{-| Initial state for the graph view.
-}
init : State
init =
    { drag = Draggable.init }



-- CONFIG


{-| Configuration of the graph view, with functions that create messages for particular events of the view.
-}
type alias Config msg =
    Draggable.Config (Mouse.State Target) msg


type alias Event msg =
    Draggable.Event (Mouse.State Target) msg


basicConfig : (Delta -> msg) -> Config msg
basicConfig =
    Draggable.basicConfig


customConfig : List (Event msg) -> Config msg
customConfig =
    Draggable.customConfig


onClick : (Mouse.State Target -> msg) -> Event msg
onClick =
    Draggable.onClick


onDragStart : (Mouse.State Target -> msg) -> Event msg
onDragStart =
    Draggable.onDragStart


onDragBy : (Delta -> msg) -> Event msg
onDragBy =
    Draggable.onDragBy


onDragEnd : msg -> Event msg
onDragEnd =
    Draggable.onDragEnd



-- UPDATE


{-| Internal messages for dealing with the view logic.
-}
type alias InternalMsg =
    Draggable.Msg (Mouse.State Target)


{-| Handle internal update messages for the view model.
-}
update : Config msg -> InternalMsg -> { model | graphView : State } -> ( { model | graphView : State }, Cmd msg )
update config msg ({ graphView } as model) =
    let
        ( graphView_, cmd ) =
            Draggable.update config msg graphView
    in
        ( { model | graphView = graphView_ }, cmd )



-- SUBSCRIPTIONS


{-| Create mouse subscriptions used for dragging.
-}
subscriptions : (InternalMsg -> msg) -> State -> Sub msg
subscriptions envelope { drag } =
    Draggable.subscriptions envelope drag



-- VIEW


{-|
Create a graph view. The first argument wraps internal messagens into an envelope for the outer application. The `Config` argument describes the messages generated by the view events. The `List Node` and `List Edge` arguments provide the graph to be displayed.

  __Note:__ The `List Node` and `List Edge` arguments should be computed with information from the model, but generally not stored in it. The `Config` is view or update code and should generally be kept separate from the model.
-}
view : (InternalMsg -> msg) -> List Node -> List Edge -> Html msg
view envelope nodes edges =
    Svg.svg
        [ style
            [ ( "margin", "20px" )
            , ( "width", "800px" )
            , ( "height", "600px" )
            ]
        ]
        [ Svg.defs [] [ arrowhead.svg ]
        , background envelope
        , edges
            |> List.map (\e -> ( toString <| edgeKey e, edgeView e ))
            |> Svg.Keyed.node "g"
                [ Attr.class "edges-view"
                , Attr.stroke "black"
                , Attr.cursor "pointer"
                ]
        , nodes
            |> List.map (\node -> ( toString node.id, nodeView envelope node ))
            |> Svg.Keyed.node "g" [ Attr.class "nodes-view" ]
        ]


background : (InternalMsg -> msg) -> Svg msg
background envelope =
    Svg.rect
        [ Attr.width "100%"
        , Attr.height "100%"
        , Attr.fill "transparent"
        , Attr.stroke "lightgrey"
        , Attr.strokeWidth "2px"
        , Attr.rx "5px"
        , Attr.ry "5px"
        , Attr.cursor "crosshair"
        , Draggable.mouseTrigger envelope (Mouse.state <| OnBackground)
        ]
        []



-- NODES


nodeView : (InternalMsg -> msg) -> Node -> Svg msg
nodeView envelope { id, name, x, y, shape } =
    let
        nodeWrapper =
            Svg.g
                [ Attr.class "node"
                , Attr.transform translate
                , Attr.cursor "pointer"
                , Draggable.mouseTrigger envelope (Mouse.state <| OnNode id)
                ]

        translate =
            "translate(" ++ toString x ++ "," ++ toString y ++ ")"
    in
        nodeWrapper <|
            case shape of
                Circle radius ->
                    [ Svg.circle
                        [ Attr.r (toString radius)
                        , Attr.fill "white"
                        , Attr.stroke "lightgrey"
                        , Attr.strokeWidth "1"
                        ]
                        []
                    , Svg.text_
                        [ Attr.textAnchor "middle"
                        , Attr.y "5"
                        ]
                        [ Svg.text name
                        ]
                    ]

                None ->
                    []



-- EDGES


edgeKey : { e | source : { b | key : a }, target : { d | key : c } } -> String
edgeKey { source, target } =
    toString ( source.key, target.key )


edgeView : Edge -> Svg msg
edgeView edge =
    let
        { source, target, length } =
            adjustEndpoints edge
    in
        Svg.path
            [ Attr.class "morphism"
            , Attr.stroke edgeColor
            , Attr.strokeWidth "1.5"
            , Attr.markerEnd ("url(#" ++ arrowhead.id ++ ")")
            , Attr.d <|
                if length == 0 then
                    "M0 0"
                    -- Dummy path, nothing should be shown
                else
                    moveTo source ++ lineTo target
            ]
            []


adjustEndpoints : Edge -> { source : Position, target : Position, length : Float }
adjustEndpoints { source, target } =
    let
        displaceBy amount { x, y } =
            { x = x + amount * dx / length
            , y = y + amount * dy / length
            }

        ( dx, dy ) =
            ( target.x - source.x, target.y - source.y )

        length =
            sqrt (dx * dx + dy * dy)
    in
        { source = source |> displaceBy (sourceDisplacement source)
        , target = target |> displaceBy (targetDisplacement target)
        , length = length
        }


sourceDisplacement : Endpoint -> Float
sourceDisplacement { shape } =
    case shape of
        None ->
            0

        Circle radius ->
            radius


targetDisplacement : Endpoint -> Float
targetDisplacement { shape } =
    case shape of
        None ->
            -arrowhead.length

        Circle radius ->
            -(radius + arrowhead.length)



-- UTILITIES


type alias Marker a =
    { id : String
    , length : Float
    , svg : Svg a
    }


type alias PathFragment =
    String


moveTo : Position -> PathFragment
moveTo { x, y } =
    "M" ++ toString x ++ " " ++ toString y


lineTo : Position -> PathFragment
lineTo { x, y } =
    "L" ++ toString x ++ " " ++ toString y



-- VIEW CONSTANTS


edgeColor : String
edgeColor =
    "black"


arrowhead : Marker a
arrowhead =
    { id = "arrowhead"
    , length = 2
    , svg =
        Svg.marker
            [ Attr.id "arrowhead"
            , Attr.viewBox "0 -5 10 10"
            , Attr.refX "8"
            , Attr.markerWidth "4"
            , Attr.markerHeight "6"
            , Attr.orient "auto"
            ]
            [ Svg.path
                [ Attr.d "M0,-5L10,0L0,5"
                , Attr.fill "transparent"
                , Attr.stroke edgeColor
                , Attr.strokeWidth "2"
                ]
                []
            ]
    }
